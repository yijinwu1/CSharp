<h1><B> 隱含型別 、匿名型別、 Dynamic型別</B></h1>

<h2><B>隱含型別的簡介</B></h2>
 var 被稱為隱含型別，在<B>編譯時期</B>宣告程隱含型別的變數。
 var 關鍵字會指示編譯器從初始化陳述式右側的運算是推斷變數的型別。<br>
推斷的型別可能是內建型別、匿名型別、使用者定義型別，或.NET Framework類別程式庫中定義的型別。<br>
也就是用 var 宣告的變數，跟自己宣告型別沒有兩樣。<br>
差別在， var 是由編譯器來幫你推斷實際型別。<br>

![1](../master/images/var1.png)

因此， var 宣告變數型別後，要馬上初始化其變數。<br>

![1](../master/images/var2.png)

<h2><B> 匿名型別的簡介</B></h2>
匿名型別提供便利的方式將<B>唯讀屬性</B>集封裝至單一物件，而不必先明確定義型別。<br>
<B>型別名稱由編譯器產生</B>。<br>
<B>來源程式碼無法使用</B>。<br>
<B>屬性的型別由編譯器推斷</B>。<br>
<B>使用 new 運算子來建立</B>。<br>

![1](../master/images/var3.png)

為什麼 var 會常被用在LINQ中呢？
因為LINQ回傳的型別是由委派的方法所決定的。<BR>
而委派方法裡面，也可以回傳匿名型別，<BR>
加上委派方法回傳內容一改，前面宣告的型別可能又要改，不如直接用 var 來宣告。

匿名型別用起來，就像 SQL 裡面 Select 了一堆table相關的資料集合後，所取用需要的欄位。<br>
每次取用的欄位數、名稱可能都不一致，但只要得到結果的人可以使用，即達成其目的。<br>
在 LINQ 使用中也是如此，針對多個物件的集合，進行交集、聯集、Group、條件判斷等操作後，組出的結果。<br>
這樣的結過組合無限多種，如果每個都定義一個具名的結構或類別，那整個定義不完。<br>
所以匿名型別在這樣的需求上，就可以相當簡便的解決問題。<br>

<h2><B> Dynamic型別的簡介</B></h2>
Dynamic所宣告的，在編譯時期為object型別。<br>
但編譯器不會去檢查這個型別的使用方式，在執行時期才決定其型別。<br>

![1](../master/images/var4.png)

var與dynamic比較
<table>
  <tr>
    <th></th>
    <th> var </th>
    <th> dynamic </th>	
	</tr>	
	<tr>
	 <td>宣告欄位</td>
	 <td>×</td>
	 <td>√</td>
	</tr>
	<tr>
	 <td>區域性變數</td>
	 <td>√</td>
	 <td>√</td>
	</tr>
	<tr>
	 <td>方法引數型別</td>
	 <td>×</td>
	 <td>√</td>
	</tr>	
	<tr>
	 <td>方法返回值型別</td>
	 <td>×</td>
	 <td>√</td>
	</tr>	
</table>
